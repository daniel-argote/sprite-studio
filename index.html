<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alpha Amnesia v1.2</title>
    <!-- Built with the assistance of Google Gemini -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Metal+Mania&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #000000;
            --bg-card: #171717;
            --bg-card-hover: #262626;
            --border-main: rgba(127, 29, 29, 0.5);
            --text-main: #e5e5e5;
            --text-muted: #737373;
            --accent: #dc2626;
            --accent-hover: #b91c1c;
            --checker-1: #171717;
            --checker-2: transparent;
            --font-title: 'Metal Mania', cursive;
        }
        body { background-color: var(--bg-main); color: var(--text-main); font-family: ui-sans-serif, system-ui; transition: background-color 0.3s, color 0.3s; }
        .font-theme { font-family: var(--font-title); letter-spacing: 0.05em; }
        .checkerboard { 
            background-image: 
                linear-gradient(45deg, var(--checker-1) 25%, var(--checker-2) 25%), 
                linear-gradient(-45deg, var(--checker-1) 25%, var(--checker-2) 25%), 
                linear-gradient(45deg, var(--checker-2) 75%, var(--checker-1) 75%), 
                linear-gradient(-45deg, var(--checker-2) 75%, var(--checker-1) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        canvas { cursor: crosshair; image-rendering: pixelated; }
        input[type=range], input[type=checkbox] { accent-color: var(--accent); }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <header class="border-b border-[var(--border-main)] p-4 flex items-center justify-between bg-[var(--bg-card)] shadow-xl z-20 transition-colors duration-300">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-[var(--accent)] rounded-lg flex items-center justify-center shadow-lg">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle></svg>
            </div>
            <h1 class="text-2xl font-theme tracking-wider text-[var(--accent)]">Alpha Amnesia <span class="text-xs font-sans font-normal text-[var(--text-muted)] ml-2 tracking-normal">v1.2</span></h1>
        </div>
        <div class="flex items-center gap-4">
            <div id="status-text" class="text-sm text-[var(--text-muted)] italic font-mono hidden md:block">Sacrifice an image to the abyss...</div>
            <button id="themeBtn" class="text-xs bg-[var(--bg-card-hover)] hover:bg-[var(--bg-main)] border border-[var(--border-main)] text-[var(--text-muted)] hover:text-[var(--accent)] px-3 py-1.5 rounded transition-all">
                Not my style
            </button>
        </div>
    </header>

    <main class="flex-1 flex overflow-hidden">
        <!-- Sidebar -->
        <aside class="w-80 border-r border-[var(--border-main)] p-6 bg-[var(--bg-main)] overflow-y-auto space-y-8 transition-colors duration-300">
            
            <section>
                <label class="text-xs font-semibold uppercase tracking-wider text-[var(--text-muted)] block mb-3">1. Background Color</label>
                <div class="flex items-center gap-3 p-3 bg-[var(--bg-card)] rounded-lg border border-[var(--border-main)]">
                    <input type="color" id="targetColor" value="#ffffff" class="w-10 h-10 rounded bg-transparent cursor-pointer">
                    <div class="flex-1">
                        <div class="text-[var(--text-main)] font-mono text-sm" id="hexDisplay">#FFFFFF</div>
                        <div class="text-[10px] text-[var(--accent)] font-bold">CLICK PREVIEW TO SAMPLE</div>
                    </div>
                </div>
            </section>

            <section class="space-y-6">
                <div>
                    <div class="flex justify-between text-sm mb-2">
                        <label class="font-semibold text-[var(--text-main)]">Tolerance</label>
                        <span id="toleranceVal" class="text-[var(--accent)] font-bold">30</span>
                    </div>
                    <input type="range" id="tolerance" min="0" max="150" value="30" class="w-full cursor-pointer">
                </div>

                <div>
                    <div class="flex justify-between text-sm mb-2">
                        <label class="font-semibold text-[var(--text-main)]">Edge Smoothing</label>
                        <span id="smoothVal" class="text-[var(--accent)] font-bold">1</span>
                    </div>
                    <input type="range" id="smoothness" min="0" max="10" value="1" class="w-full cursor-pointer">
                </div>

                <div>
                    <div class="flex justify-between text-sm mb-2">
                        <label class="font-semibold text-[var(--text-main)]">Preview Zoom</label>
                        <span id="zoomVal" class="text-[var(--accent)] font-bold">100%</span>
                    </div>
                    <input type="range" id="zoom" min="50" max="400" value="100" class="w-full cursor-pointer">
                </div>

                <div class="flex items-center justify-between pt-4 border-t border-[var(--border-main)]">
                    <label for="pixelArtToggle" class="font-semibold text-[var(--text-main)] text-sm">Pixel-Perfect Scaling</label>
                    <input type="checkbox" id="pixelArtToggle" class="w-5 h-5 cursor-pointer" checked>
                </div>

                <div class="flex items-center justify-between pt-4 border-t border-[var(--border-main)]">
                    <label for="gridSize" class="font-semibold text-[var(--text-main)] text-sm">Grid Overlay</label>
                    <select id="gridSize" class="bg-[var(--bg-card)] text-[var(--text-main)] text-xs border border-[var(--border-main)] rounded px-2 py-1 outline-none cursor-pointer">
                        <option value="0">Off</option>
                        <option value="16">16x16</option>
                        <option value="32">32x32</option>
                        <option value="64">64x64</option>
                        <option value="128">128x128</option>
                    </select>
                </div>

                <div class="pt-4 border-t border-[var(--border-main)] space-y-2">
                    <div class="flex gap-2">
                        <button id="potBtn" disabled class="flex-1 py-2 bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] text-[var(--text-main)] border border-[var(--border-main)] hover:text-white rounded-lg text-xs font-bold transition-all disabled:opacity-50 disabled:cursor-not-allowed">PAD PoT</button>
                        <button id="trimBtn" disabled class="flex-1 py-2 bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] text-[var(--text-main)] border border-[var(--border-main)] hover:text-white rounded-lg text-xs font-bold transition-all disabled:opacity-50 disabled:cursor-not-allowed">TRIM</button>
                    </div>
                    <p class="text-[10px] text-[var(--text-muted)] text-center">Resize canvas to fit content or Power of 2</p>
                </div>

                <!-- Crop Tool -->
                <div class="border-t border-[var(--border-main)] pt-4">
                    <div class="flex justify-between items-center mb-2">
                        <label class="font-semibold text-[var(--text-main)] text-sm">Crop Tool</label>
                        <button id="toggleCropBtn" class="text-xs bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] px-3 py-1 rounded text-[var(--accent)] border border-[var(--border-main)] transition-colors">Enable</button>
                    </div>
                    <div id="cropControls" class="hidden space-y-2">
                        <p class="text-[10px] text-[var(--text-muted)] uppercase tracking-wide">Drag handles to crop</p>
                        <button id="applyCropBtn" class="w-full py-2 bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] text-[var(--text-main)] border border-[var(--border-main)] hover:text-white rounded-lg text-xs font-bold transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled>APPLY CROP</button>
                    </div>
                </div>

            </section>

            <section class="pt-6 border-t border-[var(--border-main)] space-y-3">
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="askFileName" class="w-4 h-4 cursor-pointer">
                    <label for="askFileName" class="text-sm text-[var(--text-muted)] cursor-pointer select-none">Ask for filename</label>
                </div>
                <div class="flex gap-2">
                    <button id="resetBtn" class="px-4 bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] text-[var(--text-muted)] hover:text-white rounded-xl transition-colors" title="Discard & New Image">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                    </button>
                    <button id="downloadBtn" disabled class="flex-1 py-4 bg-[var(--accent)] hover:bg-[var(--accent-hover)] disabled:bg-[var(--bg-card)] disabled:text-[var(--text-muted)] rounded-xl font-bold transition-all flex items-center justify-center gap-2 shadow-lg text-white">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                        Export PNG
                    </button>
                </div>
                <button id="downloadSvgBtn" disabled class="w-full py-3 bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] disabled:bg-[var(--bg-card)] disabled:text-[var(--text-muted)] text-[var(--text-main)] hover:text-white rounded-xl font-bold transition-all flex items-center justify-center gap-2 text-sm border border-[var(--border-main)] hover:border-[var(--text-muted)]">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M9 15l2 2 4-4"></path></svg>
                    Export as SVG
                </button>

                <!-- History Tool -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label class="font-semibold text-[var(--text-main)] text-sm">History</label>
                        <div class="flex gap-2">
                            <button id="undoBtn" class="text-xs bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] px-3 py-1 rounded border border-[var(--border-main)] transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>Undo</button>
                            <button id="redoBtn" class="text-xs bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] px-3 py-1 rounded border border-[var(--border-main)] transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>Redo</button>
                        </div>
                    </div>
                    <div id="historyList" class="mt-2 space-y-1 max-h-32 overflow-y-auto pr-2">
                        <!-- History items will be injected here -->
                    </div>
                </div>
            </section>
        </aside>

        <!-- Main Workspace -->
        <div class="flex-1 relative flex items-center justify-center bg-[var(--bg-main)] overflow-hidden transition-colors duration-300">
            <div id="image-dimensions" class="absolute top-6 px-4 py-2 bg-[var(--bg-card)] backdrop-blur border border-[var(--border-main)] rounded-full text-[var(--text-main)] font-mono text-sm shadow-xl z-20 hidden pointer-events-none">
                0 x 0 px
            </div>
            <div id="drop-zone" class="absolute inset-0 z-10 flex flex-col items-center justify-center border-4 border-dashed border-[var(--border-main)] m-12 rounded-3xl transition-all">
                <div class="p-6 bg-[var(--bg-card)] rounded-full mb-4 shadow-lg">
                    <svg class="text-[var(--accent)]" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><circle cx="10" cy="13" r="2"></circle><path d="m20 17-1.09-1.09a2 2 0 0 0-2.82 0L10 22"></path></svg>
                </div>
                <p class="text-[var(--text-main)] text-xl font-medium">Drop or Paste (Ctrl+V) image here</p>
                <p class="text-[var(--text-muted)] text-sm mt-2">Works with trees, characters, or UI elements</p>
                <input type="file" id="fileInput" class="hidden" accept="image/*">
                <button onclick="document.getElementById('fileInput').click()" class="mt-6 px-6 py-2 bg-[var(--bg-card)] hover:bg-[var(--bg-card-hover)] rounded-lg text-sm font-semibold transition-all text-[var(--text-main)] hover:text-white">Select File</button>
            </div>

            <div id="canvas-wrapper" class="checkerboard shadow-2xl rounded-lg hidden overflow-auto max-w-[90%] max-h-[90%] border border-[var(--border-main)]">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>
    </main>

    <script>
        const dropZone = document.getElementById('drop-zone');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const imageDimensions = document.getElementById('image-dimensions');
        const fileInput = document.getElementById('fileInput');
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        const toleranceInput = document.getElementById('tolerance');
        const toleranceVal = document.getElementById('toleranceVal');
        const smoothnessInput = document.getElementById('smoothness');
        const smoothVal = document.getElementById('smoothVal');
        const zoomInput = document.getElementById('zoom');
        const zoomVal = document.getElementById('zoomVal');
        const targetColorInput = document.getElementById('targetColor');
        const hexDisplay = document.getElementById('hexDisplay');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadSvgBtn = document.getElementById('downloadSvgBtn');
        const resetBtn = document.getElementById('resetBtn');
        const askFileName = document.getElementById('askFileName');
        const statusText = document.getElementById('status-text');
        const toggleCropBtn = document.getElementById('toggleCropBtn');
        const cropControls = document.getElementById('cropControls');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const themeBtn = document.getElementById('themeBtn');
        const pixelArtToggle = document.getElementById('pixelArtToggle');
        const potBtn = document.getElementById('potBtn');
        const trimBtn = document.getElementById('trimBtn');
        const gridSizeSelect = document.getElementById('gridSize');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const historyList = document.getElementById('historyList');

        let originalImage = null;
        let historyStack = [];
        let historyIndex = -1;

        // --- Interaction ---
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('bg-neutral-900/50'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('bg-neutral-900/50'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));

        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (const item of items) {
                if (item.kind === 'file' && item.type.startsWith('image/')) {
                    handleFile(item.getAsFile());
                    break;
                }
            }
        });

        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    dropZone.classList.add('hidden');
                    canvasWrapper.classList.remove('hidden');
                    imageDimensions.classList.remove('hidden');
                    downloadBtn.disabled = false;
                    downloadSvgBtn.disabled = false;
                    potBtn.disabled = false;
                    trimBtn.disabled = false;
                    statusText.innerText = `Sprite: ${file.name || "Pasted Image"}`;

                    historyStack = [{ image: img, action: 'Initial Load' }];
                    historyIndex = 0;
                    updateHistoryUI();

                    processImage();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // --- Themes & Status Logic ---
        const themes = [
            {
                name: 'metal',
                vars: {
                    '--bg-main': '#000000',
                    '--bg-card': '#171717',
                    '--bg-card-hover': '#262626',
                    '--border-main': 'rgba(127, 29, 29, 0.5)',
                    '--text-main': '#e5e5e5',
                    '--text-muted': '#737373',
                    '--accent': '#dc2626',
                    '--accent-hover': '#b91c1c',
                    '--checker-1': '#171717',
                    '--checker-2': 'transparent',
                    '--font-title': '"Metal Mania", cursive'
                },
                phrases: [
                    "Sacrifice an image to the abyss...",
                    "The void hungers for pixels...",
                    "Offer your sprite to the darkness...",
                    "Cleanse the unworthy pixels..."
                ]
            },
            {
                name: 'fairy',
                vars: {
                    '--bg-main': '#fdf2f8',
                    '--bg-card': '#ffffff',
                    '--bg-card-hover': '#fce7f3',
                    '--border-main': '#fbcfe8',
                    '--text-main': '#831843',
                    '--text-muted': '#db2777',
                    '--accent': '#d946ef',
                    '--accent-hover': '#c026d3',
                    '--checker-1': '#fce7f3',
                    '--checker-2': 'transparent',
                    '--font-title': '"Dancing Script", cursive'
                },
                phrases: [
                    "Sprinkle some magic dust...",
                    "Make it sparkle!",
                    "A touch of whimsy...",
                    "Fairy wings and pixel things..."
                ]
            },
            {
                name: 'cyber',
                vars: {
                    '--bg-main': '#020617',
                    '--bg-card': '#0f172a',
                    '--bg-card-hover': '#1e293b',
                    '--border-main': '#0891b2',
                    '--text-main': '#e2e8f0',
                    '--text-muted': '#94a3b8',
                    '--accent': '#22d3ee',
                    '--accent-hover': '#06b6d4',
                    '--checker-1': '#0f172a',
                    '--checker-2': 'transparent',
                    '--font-title': '"Orbitron", sans-serif'
                },
                phrases: [
                    "Initializing pixel matrix...",
                    "Upload asset to mainframe...",
                    "Compiling visual data...",
                    "System ready for input..."
                ]
            }
        ];

        let currentThemeIndex = 0;

        function applyTheme(index) {
            const theme = themes[index];
            const root = document.documentElement;
            
            // Apply CSS Variables
            for (const [key, value] of Object.entries(theme.vars)) {
                root.style.setProperty(key, value);
            }
            
            // Update Status Text
            const randomPhrase = theme.phrases[Math.floor(Math.random() * theme.phrases.length)];
            statusText.innerText = randomPhrase;

            // Redraw canvas if image exists (to update crop lines color)
            if (originalImage) processImage();
        }

        themeBtn.addEventListener('click', () => {
            currentThemeIndex = (currentThemeIndex + 1) % themes.length;
            applyTheme(currentThemeIndex);
        });

        pixelArtToggle.addEventListener('change', () => {
            canvas.style.imageRendering = pixelArtToggle.checked ? 'pixelated' : 'auto';
        });

        gridSizeSelect.addEventListener('change', () => {
            processImage();
        });

        potBtn.addEventListener('click', () => {
            if (!originalImage) return;
            
            const w = originalImage.width;
            const h = originalImage.height;
            
            const nextPow2 = (v) => Math.pow(2, Math.ceil(Math.log2(v)));
            
            const newW = nextPow2(w);
            const newH = nextPow2(h);
            
            if (newW === w && newH === h) {
                alert("Image is already Power of 2!");
                return;
            }
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = newW;
            tempCanvas.height = newH;
            const tCtx = tempCanvas.getContext('2d');
            
            // Center the image
            const offsetX = Math.floor((newW - w) / 2);
            const offsetY = Math.floor((newH - h) / 2);
            
            tCtx.drawImage(originalImage, offsetX, offsetY);
            
            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                addToHistory(newImg, `Pad to PoT (${newW}x${newH})`);
                processImage();
            };
            newImg.src = tempCanvas.toDataURL();
        });

        trimBtn.addEventListener('click', () => {
            if (!originalImage) return;
            
            const w = originalImage.width;
            const h = originalImage.height;
            
            // Create temp canvas to analyze pixels (ignoring current zoom/display)
            const tempC = document.createElement('canvas');
            tempC.width = w;
            tempC.height = h;
            const tCtx = tempC.getContext('2d');
            tCtx.drawImage(originalImage, 0, 0);
            
            const data = tCtx.getImageData(0, 0, w, h).data;
            
            // Get current removal settings to respect visual transparency
            const hex = targetColorInput.value;
            const rT = parseInt(hex.slice(1, 3), 16);
            const gT = parseInt(hex.slice(3, 5), 16);
            const bT = parseInt(hex.slice(5, 7), 16);
            const tol = parseInt(toleranceInput.value);
            
            let minX = w, minY = h, maxX = 0, maxY = 0;
            let found = false;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const a = data[i+3];
                    
                    // Check if pixel is visually opaque
                    let isVisible = a > 0;
                    if (isVisible) {
                        const dist = Math.sqrt(Math.pow(data[i]-rT, 2) + Math.pow(data[i+1]-gT, 2) + Math.pow(data[i+2]-bT, 2));
                        if (dist <= tol) isVisible = false;
                    }
                    
                    if (isVisible) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        found = true;
                    }
                }
            }
            
            if (!found) return;
            
            const cropW = maxX - minX + 1;
            const cropH = maxY - minY + 1;
            
            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                addToHistory(newImg, `Trim Transparent (${cropW}x${cropH})`);
                processImage();
            };
            // Crop from original image to preserve pixel data
            const cropC = document.createElement('canvas');
            cropC.width = cropW;
            cropC.height = cropH;
            cropC.getContext('2d').drawImage(originalImage, minX, minY, cropW, cropH, 0, 0, cropW, cropH);
            newImg.src = cropC.toDataURL();
        });

        // --- History Logic ---
        undoBtn.addEventListener('click', () => {
            if (historyIndex > 0) {
                historyIndex--;
                originalImage = historyStack[historyIndex].image;
                processImage();
                updateHistoryUI();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                originalImage = historyStack[historyIndex].image;
                processImage();
                updateHistoryUI();
            }
        });

        function addToHistory(image, action) {
            if (historyIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyIndex + 1);
            }
            historyStack.push({ image: image, action: action });
            historyIndex++;
            updateHistoryUI();
        }

        function updateHistoryUI() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= historyStack.length - 1;

            historyList.innerHTML = '';
            historyStack.forEach((state, index) => {
                const div = document.createElement('div');
                div.className = `p-2 rounded text-xs truncate ${index === historyIndex ? 'bg-[var(--bg-card)] text-[var(--text-main)] font-semibold' : 'text-[var(--text-muted)]'}`;
                div.innerText = `${index + 1}. ${state.action}`;
                historyList.appendChild(div);
            });
        }

        // --- Crop & Sampling Logic ---
        let isCropping = false;
        let dragHandle = null; // null, 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w', 'move'
        let dragStart = { x: 0, y: 0 };
        let rectStart = { x: 0, y: 0, w: 0, h: 0 };
        let cropRect = null; // { x, y, w, h }

        toggleCropBtn.addEventListener('click', () => {
            isCropping = !isCropping;
            if (isCropping) {
                toggleCropBtn.innerText = "Disable";
                toggleCropBtn.classList.replace('text-[var(--accent)]', 'text-[var(--text-muted)]');
                cropControls.classList.remove('hidden');
                if (originalImage) {
                    // Initialize to full image
                    cropRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
                    applyCropBtn.disabled = false;
                    processImage();
                }
            } else {
                toggleCropBtn.innerText = "Enable";
                toggleCropBtn.classList.replace('text-[var(--text-muted)]', 'text-[var(--accent)]');
                cropControls.classList.add('hidden');
                cropRect = null;
                canvas.style.cursor = 'crosshair';
                processImage();
            }
        });

        function getHandle(x, y, rect, zoom) {
            if (!rect) return null;
            const handleRadius = 10 / zoom; 
            
            // Corners
            if (Math.abs(x - rect.x) <= handleRadius && Math.abs(y - rect.y) <= handleRadius) return 'nw';
            if (Math.abs(x - (rect.x + rect.w)) <= handleRadius && Math.abs(y - rect.y) <= handleRadius) return 'ne';
            if (Math.abs(x - (rect.x + rect.w)) <= handleRadius && Math.abs(y - (rect.y + rect.h)) <= handleRadius) return 'se';
            if (Math.abs(x - rect.x) <= handleRadius && Math.abs(y - (rect.y + rect.h)) <= handleRadius) return 'sw';

            // Edges
            if (Math.abs(y - rect.y) <= handleRadius && x >= rect.x && x <= rect.x + rect.w) return 'n';
            if (Math.abs(y - (rect.y + rect.h)) <= handleRadius && x >= rect.x && x <= rect.x + rect.w) return 's';
            if (Math.abs(x - rect.x) <= handleRadius && y >= rect.y && y <= rect.y + rect.h) return 'w';
            if (Math.abs(x - (rect.x + rect.w)) <= handleRadius && y >= rect.y && y <= rect.y + rect.h) return 'e';

            // Inside
            if (x >= rect.x && x <= rect.x + rect.w && y >= rect.y && y <= rect.y + rect.h) return 'move';
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!originalImage) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            const zoom = parseInt(zoomInput.value) / 100;
            
            if (isCropping) {
                const handle = getHandle(x, y, cropRect, zoom);
                if (handle) {
                    dragHandle = handle;
                    dragStart = { x, y };
                    rectStart = { ...cropRect };
                }
            } else {
                // Temporary draw of original to get true color
                ctx.drawImage(originalImage, 0, 0);
                const p = ctx.getImageData(x, y, 1, 1).data;
                const hex = "#" + [p[0], p[1], p[2]].map(x => x.toString(16).padStart(2, '0')).join('');
                targetColorInput.value = hex;
                processImage();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!originalImage) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            const zoom = parseInt(zoomInput.value) / 100;

            if (isCropping) {
                if (dragHandle) {
                    const dx = x - dragStart.x;
                    const dy = y - dragStart.y;
                    let newRect = { ...rectStart };

                    if (dragHandle === 'move') {
                        newRect.x += dx;
                        newRect.y += dy;
                        // Constrain
                        newRect.x = Math.max(0, Math.min(canvas.width - newRect.w, newRect.x));
                        newRect.y = Math.max(0, Math.min(canvas.height - newRect.h, newRect.y));
                    } else {
                        if (dragHandle.includes('w')) { newRect.x += dx; newRect.w -= dx; }
                        if (dragHandle.includes('e')) { newRect.w += dx; }
                        if (dragHandle.includes('n')) { newRect.y += dy; newRect.h -= dy; }
                        if (dragHandle.includes('s')) { newRect.h += dy; }
                        
                        // Prevent inversion
                        if (newRect.w < 1) newRect.w = 1;
                        if (newRect.h < 1) newRect.h = 1;
                    }
                    cropRect = newRect;
                    processImage();
                } else {
                    // Update Cursor
                    const handle = getHandle(x, y, cropRect, zoom);
                    if (handle === 'move') canvas.style.cursor = 'move';
                    else if (handle === 'nw' || handle === 'se') canvas.style.cursor = 'nwse-resize';
                    else if (handle === 'ne' || handle === 'sw') canvas.style.cursor = 'nesw-resize';
                    else if (handle === 'n' || handle === 's') canvas.style.cursor = 'ns-resize';
                    else if (handle === 'e' || handle === 'w') canvas.style.cursor = 'ew-resize';
                    else canvas.style.cursor = 'default';
                }
            }
        });

        window.addEventListener('mouseup', () => {
            dragHandle = null;
            if (isCropping && cropRect) applyCropBtn.disabled = false;
        });

        applyCropBtn.addEventListener('click', () => {
            if (!cropRect || cropRect.w === 0 || cropRect.h === 0) return;

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cropRect.w;
            tempCanvas.height = cropRect.h;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.drawImage(originalImage, cropRect.x, cropRect.y, cropRect.w, cropRect.h, 0, 0, cropRect.w, cropRect.h);
            
            const newImg = new Image();
            newImg.onload = () => {
                originalImage = newImg;
                // Reset Crop UI
                toggleCropBtn.click(); // Toggle off
                applyCropBtn.disabled = true;
                processImage();
            };
            newImg.src = tempCanvas.toDataURL();
        });

        // --- Image Processing ---
        function processImage() {
            if (!originalImage) return;

            const w = originalImage.width;
            const h = originalImage.height;
            const zoom = parseInt(zoomInput.value) / 100;
            
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = (w * zoom) + "px";
            canvas.style.height = (h * zoom) + "px";
            zoomVal.innerText = zoomInput.value + "%";

            ctx.drawImage(originalImage, 0, 0);

            const hex = targetColorInput.value;
            hexDisplay.innerText = hex.toUpperCase();
            const rT = parseInt(hex.slice(1, 3), 16);
            const gT = parseInt(hex.slice(3, 5), 16);
            const bT = parseInt(hex.slice(5, 7), 16);
            const tol = parseInt(toleranceInput.value);
            const smooth = parseInt(smoothnessInput.value);
            
            toleranceVal.innerText = tol;
            smoothVal.innerText = smooth;

            const imgData = ctx.getImageData(0, 0, w, h);
            const data = imgData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i+1];
                const b = data[i+2];

                const dist = Math.sqrt(Math.pow(r-rT, 2) + Math.pow(g-gT, 2) + Math.pow(b-bT, 2));

                if (dist <= tol) {
                    data[i+3] = 0;
                } else if (smooth > 0 && dist <= tol + smooth * 10) {
                    // Gradual alpha falloff for smoother edges
                    const factor = (dist - tol) / (smooth * 10);
                    data[i+3] = Math.min(data[i+3], factor * 255);
                }
            }
            ctx.putImageData(imgData, 0, 0);

            // Draw Grid Overlay
            const gridSize = parseInt(gridSizeSelect.value);
            if (gridSize > 0) {
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                ctx.lineWidth = 1 / zoom;
                ctx.beginPath();
                for (let x = gridSize; x < w; x += gridSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                }
                for (let y = gridSize; y < h; y += gridSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                }
                ctx.stroke();
            }

            // Draw Crop Overlay
            if (isCropping && cropRect) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, w, cropRect.y); // Top
                ctx.fillRect(0, cropRect.y + cropRect.h, w, h - (cropRect.y + cropRect.h)); // Bottom
                ctx.fillRect(0, cropRect.y, cropRect.x, cropRect.h); // Left
                ctx.fillRect(cropRect.x + cropRect.w, cropRect.y, w - (cropRect.x + cropRect.w), cropRect.h); // Right

                // Use computed style to get current accent color
                const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim();
                
                ctx.strokeStyle = accentColor;
                ctx.lineWidth = 2 / zoom; // Keep line width consistent regardless of zoom
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.strokeRect(cropRect.x, cropRect.y, cropRect.w, cropRect.h);
                ctx.setLineDash([]);

                // Draw Handles
                const handleSize = 6 / zoom;
                ctx.fillStyle = accentColor;
                const drawHandle = (hx, hy) => ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);

                // Corners
                drawHandle(cropRect.x, cropRect.y);
                drawHandle(cropRect.x + cropRect.w, cropRect.y);
                drawHandle(cropRect.x, cropRect.y + cropRect.h);
                drawHandle(cropRect.x + cropRect.w, cropRect.y + cropRect.h);
                // Edges
                drawHandle(cropRect.x + cropRect.w/2, cropRect.y);
                drawHandle(cropRect.x + cropRect.w/2, cropRect.y + cropRect.h);
                drawHandle(cropRect.x, cropRect.y + cropRect.h/2);
                drawHandle(cropRect.x + cropRect.w, cropRect.y + cropRect.h/2);
                
                // Update dimensions display for crop
                imageDimensions.innerText = `${Math.round(cropRect.w)} x ${Math.round(cropRect.h)} px`;
            } else {
                // Update dimensions display for full image
                imageDimensions.innerText = `${w} x ${h} px`;
            }
        }

        [toleranceInput, smoothnessInput, zoomInput, targetColorInput].forEach(el => {
            el.addEventListener('input', processImage);
        });

        downloadBtn.addEventListener('click', () => {
            let fileName = 'sprite_asset.png';
            if (askFileName.checked) {
                const input = prompt('Enter filename:', 'sprite_asset');
                if (input === null) return;
                fileName = (input.trim() || 'sprite_asset');
                if (!fileName.toLowerCase().endsWith('.png')) fileName += '.png';
            }

            const link = document.createElement('a');
            link.download = fileName;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        downloadSvgBtn.addEventListener('click', () => {
            if (!originalImage) return;

            let fileName = 'sprite_asset.svg';
            if (askFileName.checked) {
                const input = prompt('Enter filename:', 'sprite_asset');
                if (input === null) return;
                fileName = (input.trim() || 'sprite_asset');
                if (!fileName.toLowerCase().endsWith('.svg')) fileName += '.svg';
            }

            const w = canvas.width;
            const h = canvas.height;
            const data = ctx.getImageData(0, 0, w, h).data;
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" shape-rendering="crispEdges">`;
            
            // Run-Length Encoding for optimization
            for (let y = 0; y < h; y++) {
                let currentFill = null;
                let startX = 0;
                
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const a = data[i+3];
                    let fill = null;
                    
                    if (a > 0) {
                        const r = data[i], g = data[i+1], b = data[i+2];
                        fill = a === 255 
                            ? "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)
                            : `rgba(${r},${g},${b},${(a/255).toFixed(3)})`;
                    }
                    
                    if (fill !== currentFill) {
                        if (currentFill) {
                            svg += `<rect x="${startX}" y="${y}" width="${x - startX}" height="1" fill="${currentFill}" />`;
                        }
                        currentFill = fill;
                        startX = x;
                    }
                }
                if (currentFill) {
                    svg += `<rect x="${startX}" y="${y}" width="${w - startX}" height="1" fill="${currentFill}" />`;
                }
            }
            svg += '</svg>';
            
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = fileName;
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        });

        resetBtn.addEventListener('click', () => {
            originalImage = null;
            dropZone.classList.remove('hidden');
            canvasWrapper.classList.add('hidden');
            imageDimensions.classList.add('hidden');
            downloadBtn.disabled = true;
            downloadSvgBtn.disabled = true;
            potBtn.disabled = true;
            trimBtn.disabled = true;

            historyStack = [];
            historyIndex = -1;
            updateHistoryUI();
            // Reset status text based on current theme
            applyTheme(currentThemeIndex);
            fileInput.value = '';
        });
    </script>
</body>
</html>